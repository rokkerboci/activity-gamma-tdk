%----------------------------------------------------------------------------
\clearpage\section{Formal modelling}
%----------------------------------------------------------------------------


formal modeling howto, why needed, etc

semantic part, formal model, enforcing well formedness, etc

Due to the complexity of the meta-model, I have split it into multiple parts for easier understanding.


In order to offer mathematical precision, formal verification methods require formally defined models with clear semantics. 

Activities are composed of activity nodes, 

nodes have tokens
nodes are idle -> running -> done
flows can have tokens
nodes put tokens onto flows when done
node take tokens from flows when idle
if a node contains a token, it is considered running.

In this section, I present the meta-model and the formal semantics of the Gamma Activity Language.

\subsection{Formal Definition}

\begin{definition}[Gamma Activity Language]
	A Gamma Activity is a tuple of \(GA = (N, P, F, G, D, F_{Action})\), where:
	
	\begin{itemize}
		\item \(N = N_\mathit{Initial} \bigcup N_\mathit{Final} \bigcup N_\mathit{Pseudo} \bigcup N_\mathit{Decision} \bigcup N_\mathit{Merge} \bigcup N_\mathit{Action} \) is a set of \emph{Nodes}, where \(N_\mathit{Initial}\) contains the \emph{Initial} nodes, \(N_\mathit{Final}\) contains the \emph{Final} nodes, \(N_\mathit{Pseudo}\) contains the \emph{Pseudo} nodes, \(N_\mathit{Decision}\) contains the \emph{Decision} nodes, \(N_\mathit{Merge}\) contains the \emph{Merge} nodes and \(N_\mathit{Action}\) contains the \emph{Action} nodes;
		\item \( P \subseteq P_\mathit{In} \bigcup P_\mathit{Out} \) is a set of two types of pins, where \(P_\mathit{In} : N_\mathit{Action} \rightarrow \{ p_1, \dots, p_n \} \) and \(P_\mathit{Out} : N_\mathit{Action} \rightarrow \{ p_1, \dots, p_n \} \) are the set of \emph{InputPins} and \emph{OutputPins}, respectively, with domains \(\{ d_1, \dots, d_n \} \subseteq D \);
		\item \( F \subseteq F_C \bigcup F_D \), where \(F_C = \{ F_{C1}, \dots, F_{Cn} \} \) and \(F_D = \{ F_{D1}, \dots, F_{Dn} \} \) are the control and data flows, respectively. Let us denote the input/output flows of node \(n\) as \( \delta(n) \) and \( \Delta(n) \), and the source/target pins of flow \(f\) as \(\phi(f)\) and \(\Phi(f)\). For any given node \(n\), \( \delta(n) \neq \Delta(n) \) and for any given action node \(n_a\) \( \Phi(f) \in P_\mathit{In}(n_a) \forall f \in F_D \bigcap \delta(n_a) \) and \( \phi(f) \in P_\mathit{Out}(n_a) \forall f \in F_D \bigcap \Delta(n_a) \) shall always hold. This means, that a flow cannot be input and output to the same node at the same time, and for a given action node, all input/output flows shall be associated with an input/output token, respectively;
		\item \(G : F \rightarrow \{ \mathit{True}, \mathit{False} \} \) is a function determining whether a given flow is enabled;
		\item \(D = \{ D_{1}, D_{2}, \dots, D_{n} \} \) is a set of value domains;
		\item \(F_{Action} : N \rightarrow D \) is a function running the contained action, and returning it's result values.
	\end{itemize}
	
Informally, Gamma Activities are composed of \emph{nodes} (\emph{Initial/Final}, \emph{Decision/Merge}, \emph{Action} and \emph{Pseudo}) and flows (\emph{Control} and \emph{Data}) in between them. A given action can also have any number of \emph{Pins} with a domain, for which, there must be one and only one \emph{data} flow connected to the node. An action node also has a special \(F_{Action}\), which implements its specific behaviour, and returns the values of its output pins.
	
\end{definition}

\begin{definition}[Gamma Activity State]
	The state of a GA is defined the following:
	
	\begin{itemize}
		\item \(S_N : N \rightarrow \{ \mathit{Idle}, \mathit{Running}, \mathit{Done} \} \) is a function returning the \emph{state} of a node;
		\item \(S_F : F \rightarrow \{ \mathit{Empty}, \mathit{Full} \} \) is a function returning the \emph{state} of a flow;
		\item \(V_N : N \rightarrow D \) is a function returning the current \emph{value} contained in a node;
		\item \(\mathit{PV}_N : N \times P \rightarrow D \) is a function returning the current \emph{value} contained in a node's pin;
		\item \(V_F : F \rightarrow D \) is a function returning the current \emph{value} contained in a flow.
	\end{itemize}

Informally, the state of Gamma Activities are determined by the nodes' \emph{state} (\emph{Idle}, \emph{Running}, \emph{Done}) and their (or their pins') values, the flows' \emph{state} (\emph{Empty}, \emph{Full}) and their values. The following state configuration is notated with a '$\prime$'.
	
\end{definition}

\begin{definition}[State Transition Functions] 
	The state of Gamma Activities are changed by the following functions:

\begin{equation}
	F_{In} : N \rightarrow
	\begin{cases}
		\begin{aligned}[b]
			&\text{select } f_s \text{, such that} f_s \in \delta(n) \wedge S_F(f) = \mathit{Full} \\
			&V_N^\prime(n) = V_F(f_s) \\
			&S_F^\prime(f_s) = \mathit{Empty} \\
			&S_N^\prime(n) = \mathit{Running},
		\end{aligned} & \text{if } n \in N_\mathit{Merge} \\[8pt]
		\begin{aligned}[b]
			&\mathit{PV}_N^\prime(n, \Phi(f)) = V_F(f) : \forall f \in \delta(n) \bigcap F_D \\
			&S_F^\prime(f) = \mathit{Empty} : \forall f \in \delta(n) \\
			&S_N^\prime(n) = \mathit{Running},
		\end{aligned} & \text{if } n \in N_\mathit{Action} \\[8pt]
		\begin{aligned}[b]
			&V_N^\prime(n) = V_F(f) : f \in \delta(n) \bigcap F_D \\
			&S_F^\prime(f) = \mathit{Empty} : \forall f \in \delta(n) \\
			&S_N^\prime(n) = \mathit{Running},
		\end{aligned} & \text{otherwise}
	\end{cases}
\end{equation}

\begin{equation}
	F_{Run} : N \rightarrow
	\begin{cases}
		\begin{aligned}[b]
			&V_N^\prime(n) = F_{Action}(n, V_N(n)) \\
			&S_N^\prime(n) = \mathit{Done},
		\end{aligned} & \text{if } n \in N_{Action} \\[8pt]
		S_N^\prime(n) = \mathit{Done}, & \text{otherwise}
	\end{cases}
\end{equation}

\begin{equation}
	F_{Out} : N \rightarrow
	\begin{cases}
		\begin{aligned}[b]
			&\text{select } f_s \text{, such that} f_s \in \Delta(n) \wedge S_F(f_s) = \mathit{Empty} \wedge G(f_s) = \mathit{True} \\
			&V_F^\prime(f_s) = V_N(n) \\
			&S_F^\prime(f_s) = \mathit{Full} \\
			&S_N^\prime(n) = \mathit{Idle},
		\end{aligned} & \text{if } n \in N_\mathit{Decision} \\[8pt]
		\begin{aligned}[b]
			&V_F^\prime(f) = \mathit{PV}_N(n, \phi(f)) : \forall f \in \Delta(n) \bigcap F_D,
			&S_F^\prime(f) = \mathit{Full} : \forall f \in \Delta(n) \\
			&S_N^\prime(n) = \mathit{Idle},
		\end{aligned} & \text{if } n \in N_\mathit{Action} \\[8pt]
		\begin{aligned}[b]
			&S_F^\prime(f) = \mathit{Full} : \forall f \in \Delta(n) \\
			&S_N^\prime(n) = \mathit{Idle},
		\end{aligned} & \text{otherwise}
	\end{cases}
\end{equation}

At any point, any enabled function is selected and run for a node non-deterministically. 

\end{definition}

Ide fogok tenni egy szép diagrammot ami ábrázolja a fentebb említett állaotokat és függvényeket + egy rövid leírást hozzá.

\subsection{Root Structure}\label{ssec:root_structure}

Every model has to have a root element structure; Activity Language is not any different. The meta-model described in this section can be seen in \autoref{fig:declaration}.

\begin{figure}[!ht]
	\centering
	\includesvg[inkscapelatex=false, width=120mm, keepaspectratio]{declaration}
	\caption{The root structure of the language}
	\label{fig:declaration}
\end{figure}

\paragraph{Activity Declaration}\label{par:activity_declaration}

All elements inside an activity are contained in a root \emph{ActivityDeclaration} element. It contains \emph{Pins} needed for value passing (see \autoref{ssec:pins}) and a \emph{Definition}. A declaration can be \emph{InlineActivityDeclaration}, which means they are declared in an other declaration, or \emph{NamedActivityDeclaration}, which is a standalone activity declaration. The difference will be clarified in \autoref{ssec:composing_activities}.

\paragraph{Definition}\label{par:definition}

The definition \emph{defines} how the activity is described; using activity nodes, or by the Gamma Activity Language\footnote{Gamma Activity Language is a lightweight programming language-like construct for writing simple algorithms}. \emph{ActionDefinition} contains a single \emph{Block}\footnote{A \emph{Block} contains multiple \emph{Actions} which are executed one after the other}, which is executed as-is when the activity is executed\footnote{This fact means, that if one used Action to define an activity, that activity is executed atomically; it will not be interlaced with other XSTS transitions. See \autoref{ch:activiy_verification}.}. \emph{ActivityDefinition} contains \emph{ActivityNodes} (\autoref{ssec:activity_nodes}) and \emph{Flows} (\autoref{ssec:flows}).

\subsection{Activity Nodes}\label{ssec:activity_nodes}

In the following, I will talk about the different kinds of \emph{ActivityNodes} and their special meanings. All nodes are considered \emph{LAS} nodes by default. The meta-model described in this section can be seen in \autoref{fig:activity_nodes}.

\begin{figure}[!ht]
	\centering
	\includesvg[inkscapelatex=false, width=120mm, keepaspectratio]{activity_nodes}
	\caption{The Activity Node structure}
	\label{fig:activity_nodes}
\end{figure}

\paragraph{Pseudo Activity Node}

\emph{PseudoActivityNodes} are nodes, that do not represent a specific action, however are needed to convey specific meanings, e.g., the initial active node, or a decision between flows.

\paragraph{Initial Node}

\emph{InitialNodes} have one token in them when the containing activity is started. They shall only have (one or more) outgoing flows, and no input flows. 

\paragraph{Final Node}

When an activities \emph{FinalNode} gets a token the containing activity is considered \emph{Done}; after which the activity does not process any more tokens.

\paragraph{Data Node}

\emph{DataNodes} encapsulate the meaning of \emph{data} inside activities. A token may contain data (or value) of any kind, but that token can only travel to and from data \emph{sources} and \emph{targets}. More about this in \autoref{par:data_flow}.

\paragraph{Fork Node}

\emph{ForkNodes} are used to model parallelism, by creating one token on each of its output flows when executed. Fork nodes shall only have one input flow.

\paragraph{Join Node}

\emph{JoinNodes} are the pair of fork nodes; the additional created tokens are swallowed by this node, by only sending out one token, regardless of the number of input flows.

\paragraph{Decision Node}

\emph{DecisionNodes} create branches across multiple output flows. An input flows token is removed, and sent out to one, and only one of its output flows - depending on which of the output flows are \emph{enabled} (see \autoref{ssec:flows}).

\paragraph{Merge Node}

\emph{MergeNodes} 

\subsection{Composing Activities}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut vehicula turpis eget enim maximus, vel rutrum dui ullamcorper. Nulla enim ex, dapibus non aliquam vitae, molestie quis magna. Maecenas mattis turpis non ex feugiat, vitae pulvinar nisl vulputate.

\begin{figure}[!ht]
\centering
\includesvg[inkscapelatex=false, width=90mm, keepaspectratio]{composite-activity}
\caption{The }
\label{fig:composite_activity}
\end{figure}

\subsection{Flows}\label{ssec:flows}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut vehicula turpis eget enim maximus, vel rutrum dui ullamcorper. Nulla enim ex, dapibus non aliquam vitae, molestie quis magna. Maecenas mattis turpis non ex feugiat, vitae pulvinar nisl vulputate.

\paragraph{Control Flow}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut vehicula turpis eget enim maximus, vel rutrum dui ullamcorper. Nulla enim ex, dapibus non aliquam vitae, molestie quis magna. Maecenas mattis turpis non ex feugiat, vitae pulvinar nisl vulputate.

\paragraph{Data Flow}\label{par:data_flow}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut vehicula turpis eget enim maximus, vel rutrum dui ullamcorper. Nulla enim ex, dapibus non aliquam vitae, molestie quis magna. Maecenas mattis turpis non ex feugiat, vitae pulvinar nisl vulputate.

\begin{figure}[!ht]
	\centering
	\includesvg[inkscapelatex=false, width=90mm, keepaspectratio]{flows}
	\caption{The Flows structure}
	\label{fig:flows}
\end{figure}

\subsection{Pins}\label{ssec:pins}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut vehicula turpis eget enim maximus, vel rutrum dui ullamcorper. Nulla enim ex, dapibus non aliquam vitae, molestie quis magna. Maecenas mattis turpis non ex feugiat, vitae pulvinar nisl vulputate.

\paragraph{Input Pin}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut vehicula turpis eget enim maximus, vel rutrum dui ullamcorper. Nulla enim ex, dapibus non aliquam vitae, molestie quis magna. Maecenas mattis turpis non ex feugiat, vitae pulvinar nisl vulputate.

\paragraph{Output Pin}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut vehicula turpis eget enim maximus, vel rutrum dui ullamcorper. Nulla enim ex, dapibus non aliquam vitae, molestie quis magna. Maecenas mattis turpis non ex feugiat, vitae pulvinar nisl vulputate.

\begin{figure}[!ht]
\centering
\includesvg[inkscapelatex=false, width=60mm, keepaspectratio]{pins}
\caption{The Pins structure}
\label{fig:pins}
\end{figure}

\subsection{Data Source-Target Reference}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut vehicula turpis eget enim maximus, vel rutrum dui ullamcorper. Nulla enim ex, dapibus non aliquam vitae, molestie quis magna. Maecenas mattis turpis non ex feugiat, vitae pulvinar nisl vulputate.

\begin{figure}[!ht]
	\centering
	\includesvg[inkscapelatex=false, width=110mm, keepaspectratio]{data-source-target}
	\caption{The Data node reference structure}
	\label{fig:data_source_target_reference}
\end{figure}

\subsection{Pin Reference}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut vehicula turpis eget enim maximus, vel rutrum dui ullamcorper. Nulla enim ex, dapibus non aliquam vitae, molestie quis magna. Maecenas mattis turpis non ex feugiat, vitae pulvinar nisl vulputate.

\begin{figure}[!ht]
	\centering
	\includesvg[inkscapelatex=false, width=110mm, keepaspectratio]{pin-reference}
	\caption{The Data node reference structure}
	\label{fig:pin_reference}
\end{figure}

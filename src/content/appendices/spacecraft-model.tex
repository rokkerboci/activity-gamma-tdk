%----------------------------------------------------------------------------
\clearpage\section{Spacecraft Model}\label{sec:spacecraft-model}
%----------------------------------------------------------------------------

\begin{lstlisting}[float,language=statechart, caption={}, label={}]
package mission

import "Interface/Interfaces"
import "Groundstation/GroundStation"
import "Spacecraft/Spacecraft"

sync Mission [
port _control : requires StationControl
] {
	component station : GroundStation
	component satellite : Spacecraft
	bind _control -> station._control
	channel [ satellite.connection ] -o)- [ station.connection ]
}
\end{lstlisting}

\begin{lstlisting}[float,language=statechart, caption={}, label={}]
import "Mission.gcd"
component Mission

E F [ { variable satellite.batteryVariable = 14 } ]
\end{lstlisting}

\begin{lstlisting}[float,language=statechart, caption={}, label={}]
import "Interface/Interfaces.gcd"
import "Mission.gcd"

analysis {
	component : Mission
	language : Theta
	constraint : {
		minimum-orchestrating-period : SCHEDULE_CONSTRAINT ms
		maximum-orchestrating-period : SCHEDULE_CONSTRAINT ms
	}
	optimize : false
	property-file : "Mission.gpd"
}

verification {
	language : Theta
	file : "Mission.xsts"
	property-file : "Mission.gpd"
	optimize : false
}
\end{lstlisting}

\begin{lstlisting}[float,language=statechart, caption={}, label={}]
package interfaces

interface DataSource {
	out event _data
	in event ping
}

interface StationControl {
	out event start
	out event shutdown
}

const SCHEDULE_CONSTRAINT : integer := 1501
\end{lstlisting}

\begin{lstlisting}[float,language=statechart, caption={}, label={}]
activity ReceiveData {
	initial Initial
	
	merge Merge
	
	trigger DataPacket when connection._data
	
	action ProcessData
	
	control flow from Initial to Merge
	control flow from Merge to DataPacket
	control flow from DataPacket to ProcessData
	control flow from ProcessData to Merge
}
\end{lstlisting}

\begin{lstlisting}[float,language=statechart, caption={}, label={}]
activity RechargeBatteries {
	initial Initial
	
	merge Merge
	
	decision Decision
	
	action SetWait : activity [language=action] {
		set rechargeTimeout := 10s;
	}
	
	trigger Wait when timeout rechargeTimeout
	
	action Charge : activity [language=action] {
		batteryVariable := batteryVariable + 1;
	}
	
	action Full : activity [language=action] {
		batteryFullyCharged := true;
	}
	
	final Final
	
	control flow from Initial to Merge
	control flow from Merge to Decision
	control flow from Decision to SetWait [batteryVariable < 100]
	control flow from SetWait to Wait
	control flow from Wait to Charge
	control flow from Charge to Merge
	control flow from Decision to Full [batteryVariable >= 100]
	control flow from Full to Final
}
\end{lstlisting}

\begin{lstlisting}[float,language=statechart, caption={}, label={}]
activity TransmitData {				
	initial Initial
	
	fork Fork
	
	merge TransmitMerge
	decision TransmitDecision
	action SetTransmitWait : activity [language=action] {
		set transmitTimeout := 1s;
	}
	trigger TransmitWait when timeout transmitTimeout
	action TransmitData : activity [language=action] {
		_data := _data - 1024;
		raise connection._data;
	}
	
	merge ConsumeMerge
	action SetConsumeWait : activity [language=action] {
		set consumeTimeout := 1s;
	}
	trigger ConsumeWait when timeout consumeTimeout
	action ConsumeEnergy : activity [language=action] {
		batteryVariable := batteryVariable - 1;
	}
	decision ConsumeDecision
	
	merge Merge
	
	action SetDone : activity [language=action] {
		transmitionDone := true;
	}
	
	final Final
	
	control flow from Initial to Fork
	control flow from Fork to TransmitMerge
	control flow from TransmitMerge to TransmitDecision
	control flow from TransmitDecision to SetTransmitWait [_data > 0]
	control flow from SetTransmitWait to TransmitWait
	control flow from TransmitWait to TransmitData
	control flow from TransmitData to TransmitMerge
	control flow from TransmitDecision to Merge [_data <= 0]
	
	control flow from Fork to ConsumeMerge
	control flow from ConsumeMerge to SetConsumeWait
	control flow from SetConsumeWait to ConsumeWait
	control flow from ConsumeWait to ConsumeEnergy
	control flow from ConsumeEnergy to ConsumeDecision
	control flow from ConsumeDecision to ConsumeMerge [batteryVariable >= 40]
	control flow from ConsumeDecision to Merge [batteryVariable < 40]
	
	control flow from Merge to SetDone
	control flow from SetDone to Final
}
\end{lstlisting}

\begin{lstlisting}[float,language=statechart, caption={}, label={}]
package spacecraft

import "Interface/Interfaces.gcd"

@RegionSchedule = bottom-up
statechart Spacecraft [
	port connection : provides DataSource
] {
	var batteryVariable : integer := 100
	var _data : integer := 100
	
	var batteryRecharging : boolean := false
	var batteryFullyCharged : boolean := false
	var transmitionDone : boolean := false
	
	timeout rechargeTimeout
	timeout consumeTimeout
	timeout transmitTimeout
	
	region Communication { 
		initial CommunicationEntry
		state WaitingPing
		state Transmitting {
			do / call TransmitData;
		}
	}
	region Battery {
		initial BatteryEntry
		state NotRecharging
		state Recharging {
			do / call RechargeBatteries;
		}
	}
	
	transition from CommunicationEntry to WaitingPing
	transition from WaitingPing to Transmitting when connection.ping [batteryRecharging and _data > 0]
	transition from Transmitting to WaitingPing when timeout transmitTimeout [transmitionDone] 
		/ transmitionDone := false;
	
	transition from BatteryEntry to NotRecharging	
	transition from NotRecharging to Recharging when timeout consumeTimeout [batteryVariable < 80] 
		/ batteryRecharging := true;
	transition from Recharging to NotRecharging when timeout rechargeTimeout [batteryFullyCharged] 
		/ batteryFullyCharged := false; batteryRecharging := false;
	
	activity TransmitData {
		// ...
	}
	
	activity RechargeBatteries {
		// ...
	}
	
}
\end{lstlisting}

\begin{lstlisting}[float,language=statechart, caption={}, label={}]
package groundstation

import "Interface/Interfaces.gcd"

statechart GroundStation [
	port connection : requires DataSource
	port _control : requires StationControl
] {
	timeout pingTimeout
	timeout autoStart
	
	region Main {
		initial Entry
		state Idle {
			entry / set autoStart := 30s;
		}
		state Operation {
			do / call ReceiveData;
			entry / raise connection.ping; set pingTimeout := 10s;
		}
	}
	
	transition from Entry to Idle
	transition from Idle to Operation when _control.start
	transition from Idle to Operation when timeout autoStart
	transition from Operation to Operation when timeout pingTimeout
	transition from Operation to Idle when _control.shutdown
	
	activity ReceiveData {
		// ...
	}
}
\end{lstlisting}
